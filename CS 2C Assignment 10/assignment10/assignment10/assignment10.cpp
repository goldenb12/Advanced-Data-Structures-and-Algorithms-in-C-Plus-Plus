/*
Name: Brandon Goldenberg
Class: Foothill College CS 2C
Date: 3/22/2020
Instructor: Eric Reed
File Name: assignment10.cpp

Program Description: This program consists of the 100 nearest stars to Earth,
and it is updated every year to reflect newly discovered stars that might bump
some stars off the list.  In this case, the stars position is not changing, but
only the improved measurements of what is there is changing.  The data structure
StarNearEarth class contains members for each of the columns in the table in
the link used in the assignment.  Members in the class include rAsc, the right
ascension, the east-west position measured from a particular position, the
Prime Meridian, on March 21, midnight.  It's analogous to the longitude here on
Earth, but it uses celestial coordinates.  Values are in hours from 0 to 24.
In this class, the values are converted to a degree in the range of 0-360.
Another member is decl, which is the declination, or the position of the star
north or south of the celestial equator, and is analogous to the latitude here
on Earth.  Values are in degrees from +90 to -90.  The other member is
parallaxMean, which is the amount this star seems to move against the background
sky (in tiny fractions of a degree called an "arc second".  This is needed to
compute the distance in light-years which we want, but which is not part of the
data, explicitly.  As a result, getRAsc(), getDec(), and getParallaxMean() are
the accessors that are used in the program.  Once run, the program outputs the
names of some stars along with their parallax values.  Since the data is stored
from nearest to farthest (distance to our Solar System), it happens that these
values will go from largest to smallest (larger parallaxes mean closer stars).
An already provided data structure to read the files called StarNearEarthReader
is a written interface that allows the client to get the data from the file and
have a means to move it, one object at a time into an array, vector, or other
data structure that is built of StarNearEarth objects.  It can be dereferenced
with the brackets operator using indices from 0 to getNumStars() - 1.

To form a model of the galatic neighborhood of our Sun by reading this data and
then doing two things requires turning right ascension (RA), declination (DEC),
and parallax numbers in Cartesian (x, y, z) coordinates so we can work with the
positions of the stars easily.  It also requires projecting the 3-D (x, y, z)
onto a selected 2-D x-y (or x-z or y-z) plane viewing that plane on our console
as a rectangular array with the Sun in the center, and the 100 stars distributed
around it exactly as they really are in space.  The assignment operator in the
program puts the base class data into its correct positions in the derived class
object, and also sets the x, y, and z coordinates with the sought-after
Cartesian values using the method, calcCartCoords().  The math to convert
spherical coordinates to Cartesian coordinates is found by turning parallax to
distance in light years (LY) and using the formula, LY = 3.262 / parallax in
arcsec.  This gives us the so-called r of spherical coordiantes - the distance
of the star to the Earth.  To convert from degrees to radians, the formulas are:
RArad = RAdeg * (pi / 180) and DECrad = DECdeg * (pi / 180).  Combining those to
get the (x, y, z) coordinates of each star gives: x = LY cos (DECrad)
cos (RArad), y = LY cos (DECrad) sin (RArad), and z = LY sin (DECrad).  This
produces calcCartCoords().

The goal of the program is to take the x-y-z coordinates and project them onto
some plane in space, we can take the x-y plane for simplicity.  Doing so, our
projection tosses out the z coordinate and just uses x and y.  The program also
allows the client to specify an orientation plane and project onto that.  Having
100 (x,y) pairs, one for each star, we turn that into tsome *s on the screen.
Done in stages, the minimum and maximum x-coordinate is found so we know the
range of x-coordinates (same for y-coordinates).  These are known as xMin, yMin,
xMax, yMax (we can use z, instead of either x or y).  From that range of the
x-coordinate, namely xMax - xMin (same for the y-coordinates).  The constants
for the 80x80 matrix were chosen and named NUM_ROWS and NUM_COLS.  To be seen
much better visually, a 35x70 matrix is better suited for the program.  A matrix
is formed and called starMap.  This object is NUM_ROWS x NUM_COLS and has the
default character '' (blank).  In a loop, the x-y coordinates are used and
scaled using mins, ranges, and NUM_ROW/COLs calculated like earlier so that
each x value falls into the 0 - NUM_COLS and each y value falls into the
0 - NUM_ROWS range.  These scaled values are cast to int and used as coordinates
for the starMap matrix.  A '*' is placed into any location generated by these
means ('S' is placed at location (0,0).  The stars are ranked using getRank(),
which produces a number from 1 (closest) to 100 (farthest).  Those can be
replaced with '*' of the nearby stars with the ranks 1-9, stars that should
appear closer to the Sun than most of the '*'s.  Once working, the x-z and y-z
maps can also be plotted.
*/

#include <iostream>
#include "SNE_Analyzer.h"
#include "StarNearEarth.h"
#include "FHsparseMat.h"
#include <cmath>
using namespace std;

int main()
{
   string outString, longBlankString
      = "                                         "
        "                                         ";
   int k, arraySize, row, col;
   double maxX, minX, maxY, minY, maxZ, minZ,
      xRange, yRange, zRange,
      xConversion, yConversion, zConversion;
   StarNearEarthReader starInput("nearest_stars.txt");
   const int NUM_COLS = 70;
   const int NUM_ROWS = 35;

   if (starInput.readError())
   {
      cout << "couldn't open " << starInput.getFileName() << " for input.\n";
      exit(1);
   }

   cout << starInput.getFileName() << endl;
   cout << starInput.getNumStars() << endl;

   // create an array of objects for our own use:
   arraySize = starInput.getNumStars();
   SNE_Analyzer *starArray = new SNE_Analyzer[arraySize];
   for (k = 0; k < arraySize; k++)
   {
      starArray[k] =  starInput[k];
   }

   // display cartesian coords
   for (int k = 0; k < arraySize; k++)
   {
      cout << starArray[k].getNameCommon() << " "
         << starArray[k].coordToString() << endl;
   }

   // get max and min coords for scaling
   maxX = minX = maxY = minY = maxZ = minZ = 0;
   for (int k = 0; k < arraySize; k++)
   {
      if (starArray[k].getX() > maxX)
      {
         maxX = starArray[k].getX();
      }
      if (starArray[k].getX() < minX)
      {
         minX = starArray[k].getX();
      }

      if (starArray[k].getY() > maxY)
      {
         maxY = starArray[k].getY();
      }
      if (starArray[k].getY() < minY)
      {
         minY = starArray[k].getY();
      }

      if (starArray[k].getZ() > maxZ)
      {
         maxZ = starArray[k].getZ();
      }
      if (starArray[k].getZ() < minZ)
      {
         minZ = starArray[k].getZ();
      }
   }
   xRange = maxX - minX;
   yRange = maxY - minY;
   zRange = maxZ - minZ;

   // RUN 1: using y for row and x for column
   xConversion = ( NUM_COLS - 1 ) / xRange;
   yConversion = ( NUM_ROWS - 1 ) / yRange;

   // RUN 2: using x for row and y for column
   // xConversion = ( NUM_ROWS - 1 ) / xRange;
   // yConversion = ( NUM_COLS - 1 ) / yRange;

   // RUN 3: using y for row and z for column
   // yConversion = ( NUM_ROWS - 1 ) / yRange;
   // zConversion = ( NUM_COLS - 1 ) / zRange;

   // RUN 4: using x for row and z for column
   // xConversion = ( NUM_ROWS - 1 ) / xRange;
   // zConversion = ( NUM_COLS - 1 ) / zRange;

   // RUN 5: using z for row and x for column
   // xConversion = ( NUM_COLS - 1 ) / xRange;
   // zConversion = ( NUM_ROWS - 1 ) / zRange;

   // RUN 6: using z for row and y for column
   // yConversion = ( NUM_COLS - 1 ) / yRange;
   // zConversion = ( NUM_ROWS - 1 ) / zRange;

   SparseMat<char> starMap(NUM_ROWS, NUM_COLS, ' ');

   for (k = 0; k < arraySize; k++)
   {
      int rank = starArray[k].getRank();

      // RUN 1: using y for row and x for column
      row = (starArray[k].getY() - minY) * yConversion;
      col = (starArray[k].getX() - minX) * xConversion;

      // RUN 2: using X for row and Y for column
      // row = (starArray[k].getX() - minX) * xConversion;
      // col = (starArray[k].getY() - minY) * yConversion;

      // RUN 3: using y for row and z for column
      // row = (starArray[k].getY() - minY) * yConversion;
      // col = (starArray[k].getZ() - minZ) * zConversion;

      // RUN 4: using x for row and z for column
      // row = (starArray[k].getX() - minX) * xConversion;
      // col = (starArray[k].getZ() - minZ) * zConversion;

      // RUN 5: using z for row and x for column
      // row = (starArray[k].getZ() - minZ) * zConversion;
      // col = (starArray[k].getX() - minX) * xConversion;

      // RUN 6: using z for row and y for column
      // row = (starArray[k].getZ() - minZ) * zConversion;
      // col = (starArray[k].getY() - minY) * yConversion;

      if ( rank > 0 &&  rank < 10 )
      {
         starMap.set(row, col) = static_cast<char>(rank + 48);
      }
      else if( starMap.get( row, col ) == ' ' )
      {
         starMap.set(row, col) = '*';
      }
   }

   // RUN 1: using y for row and x for column
   row = (0 - minY) * yConversion;
   col = (0 - minX) * xConversion;
   cout << "\n\nRUN 1: using y for row and x for column\n\n";

   // RUN 2: using X for row and Y for column
   // row = (0 - minX) * xConversion;
   // col = (0 - minY) * yConversion;
   // cout << "\n\nRUN 2: using X for row and Y for column\n\n";

   // RUN 3: using y for row and z for column
   // row = (0 - minY) * yConversion;
   // col = (0 - minZ) * zConversion;
   // cout << "\n\nRUN 3: using y for row and z for column\n\n";

   // RUN 4: using x for row and z for column
   // row = (0 - minX) * xConversion;
   // col = (0 - minZ) * zConversion;
   // cout << "\n\nRUN 4: using x for row and z for column\n\n";

   // RUN 5: using z for row and x for column
   // row = (0 - minZ) * zConversion;
   // col = (0 - minX) * xConversion;
   // cout << "\n\nRUN 5: using z for row and x for column\n\n";

   // RUN 6: using z for row and y for column
   // row = (0 - minZ) * zConversion;
   // col = (0 - minY) * yConversion;
   // cout << "\n\nRUN 6: using z for row and y for column\n\n";

   starMap.set( row, col) = 'S';

   for (row = 0; row < NUM_ROWS; row++)
   {
      outString = longBlankString.substr(0, NUM_COLS);
      for (col = 0; col < NUM_COLS; col++)
      {
         try
         {
            outString[col] = starMap.get( row, col );
         }
         catch (...)
         {
            //cout << "Out of bounds of Sparce Matrix" << endl;
         }
      }
      cout << outString << endl;
   }

   delete[] starArray;

   return 0;
}

/*
 Output:

 nearest_stars.txt
 100
 Proxima Centauri (-1.54629, -1.18348, -3.76934)
 Barnard's Star (-0.056838, -5.94339, 0.487961)
 Wolf 359 (-7.43033, 2.11355, 0.950536)
 Lalande 21185 (-6.50637, 1.64224, 4.87005)
 Sirius (-1.60906, 8.06202, -2.46895)
 BL Ceti (7.54093, 3.47728, -2.69018)
 Ross 154 (1.91024, -8.64808, -3.91287)
 Ross 248 (7.38061, -0.583729, 7.19346)
 epsilon Eridani (6.21307, 8.31501, -1.72923)
 Lacaille 9352 (8.46565, -2.03763, -6.29226)
 Ross 128 (-10.9032, 0.583818, -0.153313)
 EZ Aquarii A (10.1892, -3.7814, -2.97361)
 Procyon (-4.76796, 10.3068, 1.03849)
 61 Cygni A (6.47533, -6.0968, 7.13794)
 (no common name) (1.08144, -5.72632, 9.94485)
 GX Andromedae (8.33256, 0.669751, 8.07912)
 epsilon Indi A (5.65677, -3.15623, -9.89375)
 DX Cancri (-6.42159, 8.38202, 5.32847)
 tau Ceti (10.2728, 5.01418, -3.26436)
 Henry et al. 1997, Henry et al. 2006 (5.02666, 6.91829, -8.40731)
 YZ Ceti (11.0276, 3.61023, -3.5473)
 Luyten's Star (-4.58412, 11.431, 1.12643)
 Henry et al. 2006 (8.72279, 8.20666, 3.63449)
 Henry et al. 2006 (1.07874, -5.4123, -11.2968)
 Kapteyn's Star (1.89052, 8.83291, -9.03874)
 AX Microscopii (7.59934, -6.53329, -8.07708)
 Kruger 60 A (6.46881, -2.74612, 11.1147)
 Jao et al. 2005, Costa et al. 2005 (-9.60648, 3.10998, -8.45318)
 Ross 614 A (-1.70526, 13.2247, -0.655389)
 Wolf 1061 (-5.14419, -12.4656, -3.02977)
 van Maanen's Star (13.6844, 2.9815, 1.3211)
 (no common name) (11.3095, 0.266851, -8.63585)
 Wolf 424 A (-13.9874, -2.04595, 2.24423)
 TZ Arietis (12.2352, 7.07964, 3.27708)
 (no common name) (-0.560574, -5.43191, 13.7496)
 (no common name) (-13.8117, 4.4737, -2.91082)
 (no common name) (-1.37941, -10.026, -10.8132)
 G 208-044 A (5.04504, -9.30115, 10.3675)
 WD 1142-645 (-6.39085, 0.398859, -13.6332)
 (no common name) (15.1756, 0.445762, -2.0094)
 Ross 780 (14.2453, -4.26849, -3.78053)
 Henry et al. 2006 (-7.11261, 2.43681, -13.6817)
 (no common name) (-11.1567, 2.70545, 10.9043)
 (no common name) (-9.16721, 4.7028, 12.0439)
 (no common name) (-13.5785, 6.36013, 5.41878)
 (no common name) (8.47021, -6.29244, -12.1422)
 (no common name) (7.58939, 10.7973, -9.38886)
 Costa et al. 2005 (7.97626, 7.63972, -11.85)
 (no common name) (-1.16803, -11.6311, -11.415)
 omicron 2 Eridani (7.16813, 14.5791, -2.18291)
 EV Lacertae (11.1863, -3.69797, 11.5109)
 70 Ophiuchi A (0.395798, -16.6257, 0.726099)
 Altair (7.68313, -14.6368, 2.57929)
 EI Cancri (-11.2661, 11.4397, 5.76843)
 Henry et al. 2006 (-0.00434369, 17.0657, 0.80679)
 Henry et al. 2006 (4.31746, 16.6814, -2.09934)
 (no common name) (-3.4371, 0.184793, 17.2119)
 Wolf 498 (-15.3243, -7.61788, 4.55075)
 (no common name) (11.7114, -12.4986, -5.22833)
 Stein 2051 (3.51678, 8.61724, 15.4759)
 (no common name) (-3.59809, 14.7553, 9.96432)
 (no common name) (2.40017, -15.3133, 10.0653)
 Wolf 1453 (2.30849, 18.4396, -1.19433)
 (no common name) (8.13711, 16.5581, -3.11497)
 sigma Draconis (2.56145, -6.00814, 17.6198)
 (no common name) (-0.806496, 17.4633, -7.0152)
 (no common name) (-0.60082, -10.2413, -15.9916)
 Wolf 1055 (6.25711, -17.9373, 1.71849)
 Ross 47 (1.45407, 18.6368, 4.14063)
 (no common name) (-12.7815, -12.502, -7.01238)
 Jao et al. 2005 (4.66587, -12.6815, -13.7781)
 (no common name) (19.3195, -0.910379, 0.811)
 eta Cassiopei A (10.083, 2.19407, 16.3959)
 (no common name) (-8.7523, -11.6374, -12.7814)
 (no common name) (18.6028, 1.25748, -5.39363)
 Ross 882 (-8.5697, 17.4409, 1.20642)
 36 Ophiuchi A (-3.3708, -17.0825, -8.72026)
 (no common name) (8.6356, -13.4, -11.6253)
 82 Eridani (9.28626, 11.0597, -13.4997)
 (no common name) (-0.336453, -6.48031, 18.7125)
 delta Pavonis (4.28382, -6.80742, -18.2207)
 QY Aurigae A (-4.71164, 14.9366, 12.4713)
 HN Librae (-15.2876, -12.1909, -4.34181)
 (no common name) (-14.1725, 10.1497, 9.86927)
 (no common name) (-9.14765, 8.06616, 16.0018)
 (no common name) (7.87021, -11.903, -14.3515)
 Wolf 562 (-13.0814, -15.5135, -2.75169)
 EQ Pegasi (19.2964, -2.38041, 7.05244)
 Henry et al. 2006 (-13.6723, 13.6255, 7.73403)
 Henry et al. 2006 (-16.0764, -2.74932, -12.9185)
 (no common name) (-3.02379, -14.2661, 14.926)
 (no common name) (-13.1994, -12.8181, -9.85069)
 (no common name) (-5.96815, -14.644, 13.6811)
 WD 0552-041 (0.443079, 20.9847, -1.53083)
 Wolf 630 A (-5.78606, -20.007, -3.05182)
 (no common name) (11.2897, -2.3337, 17.8668)
 Jao et al. 2005 (-6.34222, 4.32745, -19.8823)
 GL Virginis (-20.8614, -1.7339, 4.11654)
 (no common name) (-5.02956, -11.4863, 17.4528)
 Ross 104 (-19.3406, 5.17583, 8.42975)


 RUN 1: using y for row and x for column

                          *
                                               *
                               *     *
              *                         *
                          *    *                  *
              *                                    *
          *   *      *     *      *         *     *     *
                            *
                                  **         *
                                        7
          *                                 *
                                    2 *  *     * * *
                                   *  *
                                              *       * *    *
         *  *                                  *   *    *            *
 *                                1                                   *
                         *    *     S            8      *     *
                  *      4                         *                *
                 *      3                             *
                    *                            6     *    *
   *         *       *   *                            *
             *
                                             *    *      *
                     *   *        5     * *    9   *

            *               *                    *  *
                 *          *
             *                   *
                            * *                  *

                                    *       *     *
                      *            *    *
                                       *

                                     *
 Program ended with exit code: 0
 */
